# ~/.local/share/chezmoi/run_once_initial-setup.ps1
# ============================================================================
# Runs after `chezmoi apply` to relocate configuration files as symlink and junction to their .config relatives.
#
# This script file links the configuration file to its proper destination on
# Windows. Chezmoi will skip this script on other operating systems.
# See https://www.chezmoi.io/docs/how-to/
#
# {{- /* This file supports Go's text/template language. */}}
# {{ if eq .chezmoi.os "windows" -}}

#Requires -RunAsAdministrator

# Create missing $IsWindows if running Powershell 5 or below.
if (!(Test-Path variable:global:IsWindows)) {
	Set-Variable "IsWindows" -Scope "Global" -Value ([System.Environment]::OSVersion.Platform -eq "Win32NT")
}

# ------------------------------------------------------------------------------
#                       Explorer, Taskbar, and System Tray
# ------------------------------------------------------------------------------
Write-Host "Configuring Explorer, Taskbar, and System Tray..."

# Ensure necessary registry paths
if (-not (Test-Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer")) {
	New-Item -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" -Type Folder | Out-Null
}
if (-not (Test-Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\CabinetState")) {
	New-Item -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\CabinetState" -Type Folder | Out-Null
}
if (-not (Test-Path "HKLM:\Software\Policies\Microsoft\Windows\Windows Search")) {
	New-Item -Path "HKLM:\Software\Policies\Microsoft\Windows\Windows Search" -Type Folder | Out-Null
}

# Explorer: Show hidden files by default: Show Files: 1, Hide Files: 2
Set-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" "Hidden" 1

# Explorer: Show file extensions by default: Show Extensions: 0, Hide Extensions: 1
Set-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced" "HideFileExt" 0

# Explorer: Avoid creating Thumbs.db files on network volumes
Set-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" "DisableThumbnailsOnNetworkFolders" 1

Write-Host "...Completed configuration of Explorer, Taskbar, and System Tray"
# ------------------------------------------------------------------------------
#                       LongPaths
# ------------------------------------------------------------------------------
Write-Host "Enabling LongPaths..."
# Enable LongPaths support for file paths above 260 characters.
# See https://social.msdn.microsoft.com/Forums/en-US/fc85630e-5684-4df6-ad2f-5a128de3deef
if ($IsWindows) {
	$property = 'HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem'
	$name = 'LongPathsEnabled'
	if ((Get-ItemPropertyValue $property -Name $name) -ne 0) {
		Write-Host "LongPaths support already enabled, skipping." -ForegroundColor $ColorInfo
	}
	else {
		Write-Host "Enabling LongPaths support for file paths above 260 characters." -ForegroundColor $ColorInfo
		Set-ItemProperty $property -Name $name -Value 1
		$count++
	}
}
Write-Host "...Completed enabling of LongPaths"
# -----------------------------------------------------------------------------
#                          Default Windows Applications
# -----------------------------------------------------------------------------
Write-Host "Configuring Default Windows Applications..."

$AppsToRemove = @(
	"*.AutodeskSketchBook",
	"*.DisneyMagicKingdoms",
	"*.Facebook",
	"*.MarchofEmpires",
	"*.SlingTV",
	"*.Twitter",
	"DolbyLaboratories.DolbyAccess",
	"Microsoft.3DBuilder",
	"Microsoft.BingFinance",
	"Microsoft.BingNews",
	"Microsoft.BingSports",
	"Microsoft.BingWeather",
	"Microsoft.GetStarted",
	"Microsoft.MSPaint",
	"Microsoft.Messaging",
	"Microsoft.MicrosoftOfficeHub",
	"Microsoft.MicrosoftSolitaireCollection",
	"Microsoft.MicrosoftStickyNotes",
	# "Microsoft.Office.OneNote",
	"Microsoft.Office.Sway",
	"Microsoft.OneConnect",
	"Microsoft.People",
	"Microsoft.Print3D",
	"Microsoft.SkypeApp",
	"Microsoft.Windows.Photos",
	"Microsoft.WindowsAlarms",
	# "Microsoft.WindowsCommunicationsApps", # Mail ap,
	"Microsoft.WindowsMaps",
	# "Microsoft.WindowsPhone", # Your Phone
	"Microsoft.WindowsSoundRecorder",
	"Microsoft.XboxApp",
	"Microsoft.ZuneMusic", # Groove
	"Microsoft.ZuneVideo",
	"SpotifyAB.SpotifyMusic",
	"king.com.BubbleWitch3Saga",
	"king.com.CandyCrushSodaSaga"
)

foreach ($app in $AppsToRemove) {
	Uninstall-AppxPackage -Package $app
}
Remove-Variable -Name "AppsToRemove"
# Uninstall Windows Media Player
Disable-WindowsOptionalFeature -Online -FeatureName "WindowsMediaPlayer" -NoRestart -WarningAction SilentlyContinue | Out-Null

# Prevent "Suggested Applications" from returning
if (!(Test-Path "HKLM:\Software\Policies\Microsoft\Windows\CloudContent")) { New-Item -Path "HKLM:\Software\Policies\Microsoft\Windows\CloudContent" -Type Folder | Out-Null }
Set-ItemProperty "HKLM:\Software\Policies\Microsoft\Windows\CloudContent" "DisableWindowsConsumerFeatures" 1

Write-Host "...Completed configuration of Default Windows Applications"
#------------------------------------------------------------------------------
#                       			Chocolatey
#------------------------------------------------------------------------------
Write-Host "Configuring Chocolatey Package Manager..."
# -- Install Chocolatey on the local machine if not already present
if (-not (Get-Command "choco" -ErrorAction SilentlyContinue)) {
	Write-Host "Chocolatey not installed, installing chocolatey..."
	Set-ExecutionPolicy Bypass -Scope Process -Force
	[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
	Invoke-WebRequest -Uri https://chocolatey.org/install.ps1 -UseBasicParsing | Invoke-Expression
}

# -- Set up chocolatey configuration and features
Update-SessionEnvironment
# Default global confirmation
choco feature enable --name='allowGlobalConfirmation'
# Remember install argument for upgrades, usefull for `choco upgrade all`
choco feature enable --name='useRememberedArgumentsForUpgrades'
# Move chocolatey cache out of $TEMP for better management
choco config set --name='cacheLocation' --value='C:\ProgramData\choco-cache'
# Set higher command Execution timeout (4 hours)
choco config set --name='commandExecutionTimeoutSeconds' --value='14400'
# Change default C:\Tools\ Chocolatey tools Location to a custom one if needed
$ChocolateyToolsLocation = "{{ .choco_tools}}"
Write-Host "Updating Enviroment Variable ChocolateyToolsLocation: $Env:ChocolateyToolsLocation -> $ChocolateyToolsLocation"
[Environment]::SetEnvironmentVariable("ChocolateyToolsLocation", $ChocolateyToolsLocation, [System.EnvironmentVariableTarget]::User)
Remove-Variable -Name "ChocolateyToolsLocation"
Write-Host "...Completed configuration of Chocolatey Package Manager"
#------------------------------------------------------------------------------
#                       	Chocolatey Packages
#------------------------------------------------------------------------------
Write-Host "Configuring Packages from Chocolatey..."

# Terminals
choco install powershell
choco install pwsh --install-arguments='"REGISTER_MANIFEST=1"'
choco install microsoft-windows-terminal

# Terminal utilies
choco install curl
choco install ffmpeg
choco install nuget.commandline
choco install nvm
choco install openssh --params='"/PathSpecsToProbeForShellEXEString:$Env:ProgramFiles\PowerShell\*\Powershell.exe;$Env:WinDir\System32\WindowsPowershell\v1.0\powershell.exe"'
choco install openssl
choco install wget
choco install micro

# Git and Github
choco install gh
choco install git --params='"/GitOnlyOnPath /WindowsTerminal /NoShellIntegration"'
choco install gnupg

# Java
choco install jdk8 --params='"both=true source=false"'
choco install jre8

# Python
choco install anaconda3 --params='"/AddToPath"'

# IDE
choco install vscode --params='"/NoDesktopIcon"'
choco install sublimetext3

# FTP Client
choco install filezilla

# DotfileManager
choco install chezmoi

# Meta packages
choco install choco-cleaner
choco install choco-package-list-backup --params='"/NORUN:TRUE"'
choco install chocolateygui --params='"/ShowConsoleOutput=$true /DefaultToDarkMode=$true /Global"'

# PDF Viewer
choco install adobereader --params='"/NoUpdates"'

# Browser
choco install googlechrome

# Google drive syncronizer
choco install google-backup-and-sync

# Archiver utility
choco instal peazip

# Communication
choco install discord
choco install telegram
choco install whatsapp

# Ease of life
choco install powertoys
choco install eartrumpet
choco install f.lux
choco install speccy
# choco install everything --params='"/efu-association /run-on-system-startup /start-menu-shortcuts"'
# choco install wox

# PDF printer and editor
choco install pdf24 --params='"/Basic"'

# Media Player
choco install vlc
choco install spotify

# Image Editor
choco install paint.net

# Password Manager
choco install bitwarden
choco install bitwarden-cli

# Remote access
choco install chrome-remote-desktop-host
choco install teamviewer

# Torrent Client
choco install qbittorrent

# Make sure that all the additions to the System Variables and the enviroment are available
Update-SessionEnvironment

Write-Host "... Completed configuration of Packages from Chocolatey"
#------------------------------------------------------------------------------
#                       Powershell Modules
#------------------------------------------------------------------------------
Write-Host "Configuring Powershell Modules..."
# Set strong cryptography on 64 bit .Net Framework (version 4 and above)
Set-ItemProperty -Path 'HKLM:\SOFTWARE\Wow6432Node\Microsoft\.NetFramework\v4.0.30319' -Name 'SchUseStrongCrypto' -Value '1' -Type DWord
# Set strong cryptography on 32 bit .Net Framework (version 4 and above)
Set-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\.NetFramework\v4.0.30319' -Name 'SchUseStrongCrypto' -Value '1' -Type DWord
$tmp = (Get-Command Install-PSModules | Select-Object -ExpandProperty Definition)
if (Get-Command "powershell") {
	Write-Host "Installing modules in System Powershell..."
	Start-Process -Wait -FilePath powershell -Verb RunAs -ArgumentList "-NoLogo -NoProfile -NonInteractive -Command $tmp"
}
if (Get-Command "pwsh") {
	Write-Host "Installing modules in Core Powershell..."
	Start-Process -Wait -FilePath pwsh -Verb RunAs -ArgumentList "-NoLogo -NoProfile -NonInteractive -Command $tmp"
}
else {
	Write-Warning "Core Powershell not installed, skipping its modules installation."
}
Remove-Variable -Name "tmp"

Write-Host "... Completed configuration of Powershell Modules"
#------------------------------------------------------------------------------
#                       Functions
#------------------------------------------------------------------------------
Function Uninstall-AppxPackage {
	<#
	.SYNOPSIS
		Uninstall target AppxPackage for all users.
	.INPUTS
		System.String
	.OUTPUTS
		None
	.LINK
		Remove-AppxPackage, Remove-AppxProvisionedPackage
	#>
	[CmdletBinding()]
	Param(
		[Parameter(Mandatory = $true)]
		[String]$Package
	)

	if ($PSVersionTable.PSVersion.Major -gt 5) {
		Import-Module Appx -UseWindowsPowerShell
	}
	else {
		Import-Module Appx
	}

	Get-AppxPackage $Package -AllUsers | Remove-AppxPackage
	Get-AppxProvisionedPackage -Online | Where-Object DisplayNam -Like $Package | Remove-AppxProvisionedPackage -Online -AllUsers
}

Function Install-PSModules {
	<#
	.SYNOPSIS
		Install the default Powershell Modules that I use.
	.INPUTS
		None
	.OUTPUTS
		None
	.LINK
		Install-Module
	#>
	[CmdletBinding()]
	Param()
	# Ensure TLS1.2 is used because Powershell Gallery doesn't support anymore the older versions.
	[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
	[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

	Write-Host "Installing Powershell Gallery Modules..."
	if (!(Get-Module -ListAvailable PowerShellGet)) {
		Write-Host "PowershellGet not installed, installing PowershellGet..."
		if ((Get-PackageProvider -Name NuGet).Version.Major -le 2) {
			Install-PackageProvider -Name NuGet
		}
		Install-Module -Name PowerShellGet
	}
	Install-Module -Name FastPing -Scope CurrentUser
	Install-Module -Name oh-my-posh -Scope CurrentUser
	Install-Module -Name posh-git -Scope CurrentUser
	Install-Module -Name posh-sshell -Scope CurrentUser
	Install-Module -Name Pscx -Scope CurrentUser -AllowPrerelease
	Install-Module -Name PSReadLine -Scope CurrentUser -AllowPrerelease
	Install-Module -Name Terminal-Icons -Scope CurrentUser
	Install-Module -Name ZLocation -Scope CurrentUser
	Write-Host "...Completed installation of Powershell Gallery Modules"

	Write-Host "Installing Custom built PowerShell Modules..."
	if (Get-Command "git") {
		$MyUtilities = [PSCustomObject]@{
			Name  = "MyUtilities"
			Local = Join-Path -Path $Env:USERPROFILE -ChildPath "\.config\psmodules\MyUtilities\"
			Repo  = "https://github.com/LeoCalbi/MyUtilities.git"
		}
		$GitStatusCachePoshClient = [PSCustomObject]@{
			Name  = "GitStatusCachePoshClient"
			Local = Join-Path -Path $Env:USERPROFILE -ChildPath "\.config\psmodules\GitStatusCachePoshClient\"
			Repo  = "https://github.com/LeoCalbi/GitStatusCachePoshClient.git"
		}
		$ScreenFetch = [PSCustomObject]@{
			Name  = "ScreenFetch"
			Local = Join-Path -Path $Env:USERPROFILE -ChildPath "\.config\psmodules\ScreenFetch\"
			Repo  = "https://github.com/LeoCalbi/ScreenFetch.git"
		}
		$modules = $MyUtilities, $GitStatusCachePoshClient, $ScreenFetch
		$dst = ($Env:PSModulePath | Split-String -Separator ";")[0]
		foreach ($m in $modules) {
			if (Test-Path $m.Local) {
				Write-Warning -Message "$($m.Name) folder already found. Skipping $($m.Name) installation.";
				if ($m.Repo -eq (git config --get remote.origin.url)) {
					Write-Host "Repository checks, trying to pull latest changes."
					git fetch
					git pull
					Set-Junction -ScrPath (Get-Item -Path (Join-Path -Path $m.Local -ChildPath $m.Name)) -DstPath (Join-Path -Path $dst -ChildPath $m.Name)
					Write-Output "...$($m.Name) configuration completed."
				}
				else {
					Write-Error "$($m.Local) doesn't containt $($m.Repos) repository, check for errors."
				}
			}
			else {
				Write-Output "Starting $($m.Name) installation..."
				git clone $m.Repo $m.Local
				Set-Junction -ScrPath (Get-Item -Path (Join-Path -Path $m.Local -ChildPath $m.Name)) -DstPath (Join-Path -Path $dst -ChildPath $m.Name)
				Write-Output "...$($m.Name) configuration completed."
			}
		}
	}
	else {
		Write-Error "Git not found unable to install Custom Built Modules, skipping them."
	}
	Write-Host "...Completed installation of  Custom built PowerShell Modules"
}

Function Set-Junction {
	<#
	.SYNOPSIS
		Check target folder and create/update it using junctions to the source corresponding one.
	.INPUTS
		System.IO.FileSystemInfo
		System.String
	.OUTPUTS
		None
	.LINK
		New-Item
	#>
	[CmdletBinding()]
	Param(
		[Parameter(Mandatory = $true)]
		[String]$SrcPath,

		[Parameter(Mandatory = $true)]
		[String]$DstPath
	)
	$folder = $SrcPath.Name
	$skip = $false
	if (-not (Test-Path $DstPath)) {
		Write-Verbose "Current $folder doesn't exist in target, creating junction.";
		New-Item -ItemType Junction -Path $DstPath -Value $SrcPath
	}
	else {
		Switch ((Get-Item -Path $DstPath)) {
			($null -eq $_.LinkType) {
				Write-Verbose "Current $folder is a folder checking before transforming it into junction.";
				if ((Get-ChildItem -Path $DstPath | Measure-Object).Count -gt 0) {
					Write-Warning "$folder is not empty check the content and confirm deletion before creating junction."
					Write-Output (Get-ChildItem -Path $DstPath)
					Remove-Item -Path $DstPath -Recurse -Confirm
					if (-not (Test-Path $DstPath)) {
						Write-Verbose "Current $folder correctly deleted in target, creating junction.";
						New-Item -ItemType Junction -Path $DstPath -Value $SrcPath
					}
					else {
						Write-Warning "$folder still isn't empty skipping junction."
						$skip = $true
					}
				}
				else {
					Write-Verbose "Current $folder is empty creating junction.";
					New-Item -ItemType Junction -Path $DstPath -Value $SrcPath -Force
				}
				Break
			}
			($_.LinkType -eq "Junction") {
				if ($_.Target -ne $SrcPath) {
					Write-Warning "Current $folder is a junction but doesn't target source, it targets $($_.Target).";
					Write-Warning "Deleting current junction to create the new one."
					Remove-Item -Path $DstPath -Confirm
					if (-not (Test-Path $DstPath)) {
						Write-Verbose "Current $folder correctly deleted in target, creating junction.";
						New-Item -ItemType Junction -Path $DstPath -Value $SrcPath
					}
					else {
						Write-Warning "$folder not deleted skipping junction."
						$skip = $true
					}
				}
				else {
					Write-Verbose "Current $folder is a symlink that target source file."
				}
				Break
			}
			default {
				Write-Error -Message "Type of folder $DstPath unknown.";
			}
		}
	}
	if (-not $skip) {
		if ((Get-Item -Path $DstPath).Target -ne $SrcPath) {
			Write-Error -Message "$SrcPath and $DstPath not corresponding, check for errors.";
		}
		else {
			Write-Verbose "$folder updated succesfully."
		}
	}
	else {
		Write-Verbose "$folder configuration skipped."
	}
}


# {{- end }}
